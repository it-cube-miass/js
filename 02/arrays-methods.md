Массивы в JavaScript обладают набором полезных методов, позволяющих более гибко манипулировать их содержимым. С помощью этих методов вы можете перебирать значения массива (без использования циклов), трансформировать массив и делать другие полезные вещи. В этом материале мы на примерах разберём наиболее полезные и часто применяемые методы массивов.

## Перебор значений массива (forEach)
Одна из частых задач при работе с массивами — перебор значений. Если мы храним набор значений, то рано или поздно возникнет необходимость проделать какую-то операцию с элементами этого набора. Для решения этой задачи можно воспользоваться операторами циклов ```for``` или ```while```, или сделать тоже самое с помощью метода ```forEach```.

Метод forEach позволяет выполнить произвольную функцию однократно для каждого элемента. Попросту говоря: он запускает перебор значений массива и для каждого значения выполняет функцию. Рассмотрим пример:
```javascript
const fruits = ['banana', 'apple', 'lemon', 'orange'];

fruits.forEach(function (value, index, array) {
   console.log(value);
});

// Выведет:
// banana
// apple
// lemon
// orange
```
В примере выше мы определяем такую функцию с тремя параметрами:
- ```value``` — текущий элемент массива;
- ```index``` — порядковый номер текущего элемента массива;
- ```array``` — ссылка на сам массив.

Эти параметры будут доступны при каждом вызове функции.

Если вам не требуется порядковый номер элемента в массиве или как-то взаимодействовать с массивом, то соответствующие параметры в функции можно не определять:
```javascript
fruits.forEach(function (value) {
  console.log(value);
});
```
При использовании метода ```forEach``` стоит помнить одну важную деталь: работу метода нельзя остановить. Оператор ```break``` не поможет. Поэтому если вам требуется перебрать только часть массива, то ```forEach``` следует отодвинуть в сторонку, и воспользоваться циклом ```for```. Помните об этом.

## Преобразование массива (map)
Вторая по популярности задача при работе с массивами — преобразование. С помощью этого метода мы можем итерироваться по массиву и в результате получить новый массив. Рассмотрим пример. Предположим у нас есть массив ```films``` с фильмами. Каждый фильм описан в виде объекта с двумя ключами:
- ```id``` — идентификатор фильма;
- ```title``` — название фильма.

Примерно вот так:
```javascript
const films = [
  {
    id: 0,
    title: "Die hard"
  },
  {
    id: 1,
    title: "Terminator 2"
  }
];
```
Наша задача заключается в получении массива, который будет содержать только названия фильмов. То есть на выходе мы должны получить массив вида: ```["Die hard", "Terminator 2"]```.

У любой задачи всегда есть, как минимум, два решения. Можно решить её «в лоб» и воспользоваться знаниями о методе ```forEach```. Алгоритм будет таким: заводим новый массив и начинаем перебирать ```films``` методом ```forEach```. В функции, которая будет вызываться для каждого элемента, напишем код для добавления названия фильма в новый массив. На этом задача можно сказать решена. Пример такого решения:
```javascript
const titles = [];

films.forEach(function (film, index) {
   titles[index] = film.title;
});

console.log(titles); // ["Die hard", "Terminator 2"]
```
Код работает, однако нам нужно руками заводить пустой массив ```titles```, руками в него добавлять элементы. Зачем, если существует метод ```map```, который может взять эти обязанности на себя:
```javascript
const titles = films.map(function (film) {
   return film.title;
});

console.log(titles); // ["Die hard", "Terminator 2"]
```
Результатом выполнения метода map будет новый массив, собранный из значений, которые вернёт функция, переданная в качестве параметра методу ```map```.

Кстати, параметры метода ```map``` такие же, как у ```forEach``` — ```currentValue, index, array```. Выходит, что метод map похож на ```forEach```. Только он позволяет не просто перебрать все значения массива, а получить новый массив значений.

Метод map удобно использовать, когда требуется трансформировать массив, то есть создать новый массив на основе существующего.

## Перевернуть массив (reverse)
```reverse``` — метод массива, который может его «перевернуть» с ног на голову. Он вернёт **новый массив**, который будет состоять из элементов, расположенных в обратном порядке. Рассмотрим на примере массива с числами:
```javascript
const numbers = [0, 1, 2, 3, 4];
const reverseNumbers = numbers.reverse();
console.log(reverseNumbers); // [4, 3, 2, 1, 0]
```

## Проверить значение массива (some)
Метод ```some``` тоже относится к перебирающим методам массива. То есть это очередной метод, позволяющий перебрать элементы массива, но с одной особенностью. С его помощью можно проверить присутствует ли в массиве элемент, который удовлетворяет определенному условию. Результатом выполнения метода ```some``` будет булево значение: ```true``` или ```false```.

Метод ```some``` перебирает элементы массива и для каждого элемента вызывает переданную функцию. Метод ```some``` будет вызывать функцию для каждого элемента, пока она не вернёт ```true```. Как только это случится, метод ```some``` прервёт работу и вернёт в качестве результата значение ```true```.

Если для всех элементов массива переданная функция вернёт ```false```, тогда результатом ```some``` станет ```false```. Получается, метод ```some``` решает задачу проверки элементов массива на соответствие какому-то условию. Рассмотрим на практическом примере:
```javascript
const numbers = [1, 4, 10, 5];

// Проверяем каждый элемент, больше ли он, чем 5
// Когда some дойдёт до 10, то прекратит работу и вернёт true
const isExistsOverFive = numbers.some(function (value) {
   return value > 5;
});
console.log(isExistsOverFive); // true

// Проверяем каждый элемент, больше ли он, чем 20
// some пройдёт все элементы, они все меньше 20, поэтому он вернёт false
const isExistsOverTwenty = numbers.some(function (value) {
   return value > 20; 
}); 
console.log(isExistsOverTwenty); // false
```
У метода ```some``` есть одна особенность. Если вызвать его на пустом массиве, то результатом всегда будет ```false```. Вне зависимости от условия:
```javascript
const result = [].some(function (value) {
  return 1 === 1;
}); // так как массив пустой, some вернёт false
```

## Проверить элементы массива (every)
Если метод ```some``` позволяет убедиться, что хотя бы один элемент массива удовлетворяет условию, то при помощи метода ```every``` можно проверить, что условию соответствуют все элементы массива. Результатом вызова метода ```every``` будет булево значение: ```true``` или ```false```.

Метод ```every``` так же аргументом принимает функцию, которая будет вызываться для каждого элемента до тех пор, пока при проверке условия не вернётся ```false```. В таком случае метод ```every``` прекратит выполнение и вернёт ```false```. Если для каждого элемента массива будет возвращено значение ```true```, то результатом метода ```every``` также станет ```true```:
```javascript
const numbers = [11, 12, 13, 15, 100];

const isEveryNumberOverTen = numbers.every(function (value) {
  return value > 10;
}); // every вернёт true, потому что все элементы массива больше 10
```
Добавим в массив ```numbers``` элемент меньше ```10```:
```javascript
const numbers = [11, 12, 13, 15, 100, 9];

const isEveryNumberOverTen = numbers.every(function (value) {
  return value > 10;
}); // every вернёт false, потому что один элемент массива меньше 10
```
У метода ```every``` есть одна особенность. Если вызвать его на пустом массиве, то результатом всегда будет ```true```. Вне зависимости от условия:
```javascript
const result = [].every(function (value) {
  return 1 === 1;
}); // every всё равно вернёт true, хотя массив пустой
```

## Поиск элемента (find)
Метод ```find``` позволяет решить одну из самых часто возникающих задач при работе с массивами — осуществить поиск элемента. Раз массивы позволяют хранить наборы значений, то рано или поздно может потребоваться найти значение, которое соответствует определенному условию.

Метод ```find``` как и другие методы аргументом принимает функцию, которая будет вызвана для каждого элемента массива, пока не найдётся элемент, который удовлетворяет условию. Как только такой элемент будет найден, метод ```find``` прекратит работу и вернёт найденный элемент. Рассмотрим на примере поиска фильма в массиве:
```javascript
const films = [
  {
    id: 0,
    title: "Die hard"
  },
  {
    id: 1,
    title: "Terminator 2"
  }
];

const t2 = films.find(function (film) {
  return film.title === "Terminator 2";
});

console.log(t2); // { id: 1, title: "Terminator 2" }
```
Но что вернёт функция, если в массиве есть несколько элементов, удовлетворяющих условию? Ответ прост: первый элемент, который соответствует условию. После этого работа метода будет прервана.

## Свернуть массив (reduce)
Напоследок рассмотрим метод ```reduce```. Это ещё один метод, позволяющий перебрать содержимое массива. Его основная задача — свернуть массив, то есть из набора значений получить одно. Это значение может быть произвольного типа. За счёт этой возможности, метод ```reduce``` становится мощным инструментом, позволяющий решить множество разных задач.

Перед тем, как познакомиться с примером, давайте рассмотрим аргументы:
```javascript
array.reduce(callback[, initialValue]);
```
Первым параметром метод принимает функцию, а вторым начальное значение аккумулятора (опционально). Аккумулятором называют результирующее значение.

Теперь разберём параметры функции:
```javascript
array.reduce(function (accumulator, currentValue, index, array) {});
```
Их аж четыре:

- ```accumulator``` — тот самый аккумулятор или промежуточное значение. Через этот параметр вы сможете получить предыдущий результат выполнения функции;
- ```currentValue``` — текущий элемент массива;
- ```index``` — порядковый номер текущего элемента;
- ```array``` — ссылка на массив.

Рассмотрим применение метода ```reduce``` на практическом примере. Начнём с наиболее простой задачи: суммирование всех значений массива.

Для наглядности опишем задачу так: есть корзина с товарами (массив), где каждый товар представлен объектом с несколькими ключами: ```title``` (название товара), ```quantity``` (количество) и ```price``` (цена). Наша задача заключается в подсчёте общей суммы товаров и в этом нам поможет метод reduce:
```javascript
const goods = [
  {
    title: 'Кукуруза',
    quantity: 3,
    price: 99
  },
  {
    title: 'Корм для кота',
    quantity: 2,
    price: 113
  }
];

const sum = goods.reduce(function (accumulator, product) {
  return accumulator + (product.quantity * product.price);
}, 0);

console.log(sum); // 523
```
В этом примере мы посчитали сумму товаров и для этого нам потребовалась одна строчка кода и никаких дополнительных переменных.

Как это работает?! Метод ```reduce``` вызывает функцию для каждого элемента массива. Результат выполнения этой функции доступен на следующей итерации через параметр ```accumulator```. Таким образом, функция аккумулирует результат. После завершения перебора массива, метод ```reduce``` вернёт в качестве значения значение ```accumulator```, которое было накоплено в результате итерирования по массиву.

Внутри функции мы выполняем простое действие: прибавляем к аккумулятору результат произведения количества и стоимости. Начальное значение аккумулятора будет 0 (второй аргумент ```reduce```).

Теперь давайте разберём, как будет выполняться этот код. На первой итерации значением аккумулятора будет 0 — мы определили его самостоятельно, передав вторым параметром в метод ```reduce```. Получается, что выражение в итоге будет таким:
```javascript
0 + (3 * 99) = 297;
```
На первой итерации мы посчитали стоимость первого товара («Кукуруза»). На второй итерации мы переходим к следующему товару — «Корм для кота». На этот раз значением ```accumulator``` будет ```297```, результат выполнения функции на прошлой итерации, и к этому значению мы прибавляем стоимость второго товара:
```javasript
297 + (2 * 113) = 523;
```
Поскольку больше элементов в массиве нет, то метод ```reduce``` завершит работу и вернёт значение ```accumulator``` — ```523```.

## Резюме
Рассмотренные в этом разделе методы для работы с массивами не единственные. Мы привели наиболее часто используемые. Информацию о других методах массивов, вы всегда можете найти в [справочнике разработчика MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array).

