В предыдущем разделе мы затронули понятия экспорта ```export``` и импорта ```import```, как способ взаимодействия между модулями. Существует два способа такого взаимодействия и несколько их комбинаций. Начнём с самого простого, и в то же время самого надёжного способа.
> Обратите внимание, импорт и экспорт похожи на деструктуризацию, но только похожи.

## Именованные экспорт и импорт
Всё просто, в одном модуле мы явно говорим, что хотим экспортировать:
```javascript
// файл mother.js
const name = `Eve`;
const age = 18;

export const sex = `female`; // экспорт при объявлении

export { name, age }; // экспорт уже объявленных переменных
```
А в другом явно это импортируем:
```javascript
// файл сain.js
import { name } from './mother.js';

console.log(`My mother is`, name);
```
Имена переменных должны совпадать полностью. Если запрашиваемой переменной нет среди экспортируемых, то будет выкинута ошибка, и модуль не загрузится.

Обратите внимание: импортировать всё, что экспортирует модуль, необязательно.

Экспортировать одну и ту же переменную дважды нельзя:
```javascript
// файл mother.js
const name = `Eve`;
const age = 18;

export const sex = `female`;

export { sex };
```
Но если очень надо, есть способ — переименование при экспорте/импорте. О нём поговорим чуть позже.

Обратите внимание, импортированная переменная не создаётся в модуле.

Мы импортируем не копию, а настоящую переменную из другого модуля. Такое поведение справедливо для всех видов импорта (экспортировать как-то иначе тоже нельзя), которые мы разберём дальше, поэтому будьте внимательны при работе с импортированными переменными. Ведь сложные типы данных, вроде объектов или массивов, передаются по ссылке, и их можно нечаянно испортить.
```javascript
// файл items.js
const items = [`one`, `two`, `three`];

export { items };

// файл filter.js
import { items } from './items.js';

items.sort(); // испортили массив в модуле items.js, хотя сортируем в filter.js
```
Поэтому не забывайте про ```Object.assign()``` и ```Array.prototype.slice()``` и им подобные методы, когда работаете с импортированной структурой.
```javascript
// файл items.js
const items = [`one`, `two`, `three`];

export { items };

// файл filter.js
import { items } from './items.js';

items.slice().sort(); // отсортировали копию, исходный массив в items.js остался цел
```
С примитивами тоже не всё так просто. Даже если импортируете ```let```-переменную, по спецификации движок JavaScript не позволит вам изменить её. Она считается read-only переменной (доступной только для чтения).
```javascript
// файл mother.js
let name = `Eve`;

export { name };

// файл сain.js
import { name } from './mother.js';

name = `Adam`; // ничего не выйдет
```
Поэтому распространённой практикой является экспорт только ```const```-значений и им подобных (классов, например).

## Переименованный экспорт и импорт
Бывают случаи, когда в одном модуле экспортируется переменная, которая уже существует в другом.
```javascript
// файл сain.js
import { name } from './mother.js';
import { name } from './father.js';

const name = `Сain`;

// ??? три переменных name... не может быть

```
Объявлена она как переменная или экспортирована из третьего модуля — неважно. Имя занято. Да, можно, конечно, изменить название в экспортирующем модуле. Но, во-первых, это не гибкое решение, во-вторых, если модуль не ваш, а чужой, там ничего поменять не получится.

На эти случаи в спецификации есть решение. Импортируемые переменные можно переименовывать:
```javascript
// файл сain.js
import { name as motherName } from './mother.js';
import { name as fatherName } from './father.js';

const name = `Сain`;

console.log(`My mother is`, motherName);
console.log(`My father is`, fatherName);
console.log(`My name is`, name);
```
Таким же образом можно переименовать переменную при экспорте. Случай более редкий, но такая возможность есть.
```javascript
// файл mother.js
const name = `Eve`;

export { name as motherName };

// файл сain.js
import { motherName } from './mother.js';
```

## Экспорт по умолчанию
Синтаксически экспорт по умолчанию отличается вводом дополнительного ключевого слова ```default```:
```javascript
// файл mother.js
const mother = {
    name: `Eve`,
    age: 18,
    sex: `female`,
};

export default mother;
```
Фигурные скобки не нужны, поскольку экспортировать по умолчанию можно лишь одну переменную.

Поведенческое отличие такого экспорта от именованного — возможность экспортировать значение, а не переменную.
```javascript
// файл mother.js
export default {
    name: `Eve`,
    age: 18,
    sex: `female`,
};
```
Из-за этого отличается и импорт такого значения «по умолчанию». Раз у нас может не быть переменной, то под каким именем импортировать? Под любым!
```javascript
// файл mother.js
export default {
    name: `Eve`,
    age: 18,
    sex: `female`,
};

// файл сain.js
import father from './mother.js';
```
В этом заключается и главная особенность, и главная проблема экспорта по умолчанию, что мы можем задать любое имя.

Это проблема, потому что такое поведение усложняет отладку, навигацию по коду и в конце концов мы можем импортировать то, что модуль не экспортирует.

## Переименованный экспорт и импорт по умолчанию
Если вдруг вам нужно экспортировать переменную как ```default```, а писать ```export default myVar``` почему-то не хочется, можно воспользоваться уже знакомым синтаксисом переименования:
```javascript
// файл mother.js
const mother = {
    name: `Eve`,
    age: 18,
    sex: `female`,
};

export { mother as default };
```
Никаких отличий или преимуществ, кроме лишних скобок и выражения ```as```, в этом способе нет.

Аналогичный способ можно использовать при импорте:
```javascript
// файл mother.js
export default {
    name: `Eve`,
    age: 18,
    sex: `female`,
};

// файл сain.js
import { default as mother } from './mother.js';
```
Тоже никаких отличий или преимуществ перед обычным импортом ```import mother from './mother.js'.```

## Экспорт построчно или экспорт группой
Эти два способа уживаются друг с другом:
```javascript
// файл mother.js
const name = `Eve`;
const age = 18;

export const sex = `female`;

export { name, age };
```
Ради единого стиля кодирования стоит выбрать что-то одно: либо экспорт при объявлении, либо в конце файла группой. Лучше второй, потому что он нагляднее.

## Импортировать как…
Когда у модуля только именованный экспорт, перечислять все переменные — трудоёмкая задача. Для этого можно воспользоваться конструкцией ```import *``` и импортировать все именованные экспорты в одно пространство имён:
```javascript
// файл mother.js
const name = `Eve`;
const age = 18;

export const sex = `female`;

export { name, age };

// файл сain.js
import * as mother from './mother.js';
```
> Будьте внимательны, такой импорт игнорирует экспорт по умолчанию, даже если он есть в модуле. А ещё такой способ является небезопасным, потому что мы импортируем всё и сразу, при этом не знаем, что именно.

## Проксирование
Иногда удобно, чтобы один файл экспортировал значения сразу нескольких. Можно вручную импортировать всё, а потом экспортировать вручную. Но зачем делать вручную, когда для этого есть специальный синтаксис:
```javascript
// файл mother.js
const name = `Eve`;

export { name as motherName };

// файл father.js
const name = `Adam`;

export { name as fatherName };

// файл parents.js
export * from './mother.js';
export * from './father.js';

// файл сain.js
import { motherName, fatherName } from './parents.js';

console.log(`My mother is`, motherName);
console.log(`My father is`, fatherName);
```

## Импорт без переменной
Когда нам нужно только выполнить код модуля, достаточно его просто импортировать:
```javascript
// файл alert.js
alert(`Hello, world!`);

// файл index.js
import './alert.js';
```

## Когда что использовать
* Если имя переменной имеет важность или модуль экспортирует несколько значений, лучше пользоваться именованным экспортом.
* Если модуль экспортирует ровно одно значение, то лучше воспользоваться конструкцией ```export default```.

## Нюансы
### Только первый уровень
```import``` и ```export``` не могут быть вложены в функции или другие блоки кода:
```javascript
// файл сain.js
if (true) {
    // так нельзя
    import { name as motherName } from './mother.js';
}

const name = `сain`;

if (true) {
    // так тоже нельзя
    export { name };
}
```

### Никакого поднятия (hoisting)
Импортированные переменные не поднимаются, поэтому ```import``` всегда должен быть в начале файла:
```javascript
// файл сain.js
const name = `сain`;

console.log(`My mother is`, motherName);

// так нельзя, браузер выдаст ошибку
import { name as motherName } from './mother.js';
```

### Импорт того, чего нет
Если импортировать переменную, которая в модуле не экспортируется, получим ошибку.

### Динамический импорт
Он существует. Разбирать мы его пока не будем, потому что у него нет полной поддержки браузерами.

## Резюме
Во всех наших примерах мы импортировали переменные из модулей — файлов, лежащих рядом. Но импортировать можно много чего ещё. 
