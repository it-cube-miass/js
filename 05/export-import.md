В предыдущем разделе мы затронули понятия экспорта ```export``` и импорта ```import```, как способ взаимодействия между модулями. Существует два способа такого взаимодействия и несколько их комбинаций. Начнём с самого простого, и в то же время самого надёжного способа.
> Обратите внимание, импорт и экспорт похожи на деструктуризацию, но только похожи.

## Именованные экспорт и импорт
Всё просто, в одном модуле мы явно говорим, что хотим экспортировать:
```javascript
// файл mother.js
const name = `Eve`;
const age = 18;

export const sex = `female`; // экспорт при объявлении

export { name, age }; // экспорт уже объявленных переменных
```
А в другом явно это импортируем:
```javascript
// файл сain.js
import { name } from './mother.js';

console.log(`My mother is`, name);
```
Имена переменных должны совпадать полностью. Если запрашиваемой переменной нет среди экспортируемых, то будет выкинута ошибка, и модуль не загрузится.

Обратите внимание: импортировать всё, что экспортирует модуль, необязательно.

Экспортировать одну и ту же переменную дважды нельзя:
```javascript
// файл mother.js
const name = `Eve`;
const age = 18;

export const sex = `female`;

export { sex };
```
Но если очень надо, есть способ — переименование при экспорте/импорте. О нём поговорим чуть позже.

Обратите внимание, импортированная переменная не создаётся в модуле.

Мы импортируем не копию, а настоящую переменную из другого модуля. Такое поведение справедливо для всех видов импорта (экспортировать как-то иначе тоже нельзя), которые мы разберём дальше, поэтому будьте внимательны при работе с импортированными переменными. Ведь сложные типы данных, вроде объектов или массивов, передаются по ссылке, и их можно нечаянно испортить.
```javascript
// файл items.js
const items = [`one`, `two`, `three`];

export { items };

// файл filter.js
import { items } from './items.js';

items.sort(); // испортили массив в модуле items.js, хотя сортируем в filter.js
```
Поэтому не забывайте про ```Object.assign()``` и ```Array.prototype.slice()``` и им подобные методы, когда работаете с импортированной структурой.
```javascript
// файл items.js
const items = [`one`, `two`, `three`];

export { items };

// файл filter.js
import { items } from './items.js';

items.slice().sort(); // отсортировали копию, исходный массив в items.js остался цел
```
С примитивами тоже не всё так просто. Даже если импортируете ```let```-переменную, по спецификации движок JavaScript не позволит вам изменить её. Она считается read-only переменной (доступной только для чтения).
```javascript
// файл mother.js
let name = `Eve`;

export { name };

// файл сain.js
import { name } from './mother.js';

name = `Adam`; // ничего не выйдет
```
Поэтому распространённой практикой является экспорт только ```const```-значений и им подобных (классов, например).
