**Модуль** — это функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом.

Отдельный файл — это отдельный файл. Нечего добавить. Поговорим подробнее про «функционально законченный фрагмент программы».

Законченный фрагмент кода — это фрагмент, который выполняет вполне конкретную поставленную задачу и ничего лишнего. Мы будем писать модули в разных файлах, где 1 файл = 1 модуль, который выполняет одну конкретную задачу. Но сначала давайте на примере разберёмся, зачем вообще нужны модули.

Представим, что нам поставили задачу построить самолёт. Нельзя просто так взять и построить самолёт. Сперва одна команда инженеров должна разработать чертежи, после другая команда техников должна собрать по этим чертежам фюзеляж, параллельно третья команда должна разработать двигатели для самолёта, четвёртая — авионику, пятая — салон, и так далее. Если в будущем потребуется модифицировать этот самолёт, то при таком подходе не нужно будет разрабатывать самолёт заново, достаточно будет изменить что-то одно. Например, салон. Возьмём для примера самолёт Boeing 737. Кто часто летает, обращал внимание: у национального перевозчика несколько рядов бизнес-класса и пару десятков эконом-класса. А вот у лоукостера — 32 ряда и все эконом-класса. В обоих случаях самолёт один и тот же — Boeing 737. Так и с приложением.

## Преимущества модульного подхода
* Каждая команда фокусируется на своей задаче.
* Некоторые команды могут делать свою работу параллельно и независимо друг от друга.
* Команду или результат её работы можно легко заменить (в сравнении с немодульным подходом). Пример выше — в самолёт без проблем можно установить салон другой комплектации или от другого производителя, не изменяя конструкцию самолёта.

Из преимуществ вытекает другое правило — модули должны быть максимально универсальными.

## Задачи модуля
### Пространство имён
Модуль изолирует пространство имён, чтобы переменные из одного модуля не попадали в другой модуль, как это бывает с глобальными переменными. Всё, что создаётся в модуле, остаётся в модуле.
```javascript
// файл src/mother.js
const name = `Eve`;

// файл src/father.js
const name = `Adam`;
```
Таким образом мы создадим два модуля ```mother.js``` и ```father.js```, где в каждом будет своя переменная name. Ни одна из них не попадёт в глобальную область видимости ```window```, а значит, не будет никаких конфликтов.

### Зависимости
Модуль должен описывать и давать понимание, какие у него есть зависимости. Например, модуль может зависеть от других модулей.
```javascript
// файл сain.js
import { name } from './mother.js';

console.log(`My mother is`, name);
```
С синтаксисом импортов ```import``` мы познакомимся в следующем разделе. Мы видим, модуль ```сain.js``` зависит от модуля ```mother.js``` и выводит в консоль переменную ```name```, полученную из этого модуля.

### Интерфейс
Модуль должен описывать интерфейс — методы и свойства — которые он может предоставить другим модулям. Чтобы прошлый пример работал, нам нужно показать, что у него в интерфейсе есть свойство ```name```, которое могут использовать другие модули.
```javascript
// файл mother.js
const name = `Eve`;

export { name };
```
С синтаксисом экспортов ```export``` мы познакомимся в следующем разделе.

## Модули до ECMAScript 2015
Раньше в JavaScript не было штатной возможности писать модульный код, поэтому разработчики выдумывали обходные пути. Например, использовали [IIFE (Immediately Invoked Function Expression)](http://benalman.com/news/2010/11/immediately-invoked-function-expression/).
```javascript
// файл mother.js
'use strict';
(function() {
  window.mother = {
    name: `Eve`,
  };
})();
```
Суть этого подхода была в том, что задача пространства имён решалась с помощью области видимости IIFE, интерфейс реализовывался с помощью явной записи методов модуля в глобальную область видимости window, таким же образом использовались зависимости. В качестве примера давайте рассмотрим организацию семьи в модульном подходе с помощью IIFE:
```javascript
// файл mother.js
'use strict';
(function() {
    window.mother = {
        name: `Eve`,
    };
})();

// файл father.js
'use strict';
(function() {
    window.father = {
        name: `Adam`,
    };
})();

// файл сain.js
'use strict';
(function() {
    console.log(`My mother is`, window.mother.name);
    console.log(`My father is`, window.father.name);
})();
```
У такого подхода был ряд проблем: ручное подключение, необходимость помнить порядок использования зависимостей и так далее.

На замену этому подходу начали появляться другие: [AMD](https://github.com/amdjs/amdjs-api/wiki/AMD), [CommonJS](http://www.commonjs.org/), [UMD](https://github.com/umdjs/umd). Не будем останавливаться на них подробно, при желании описание и принципы их работы вы найдёте по ссылкам.

Всё это самописное продолжалось достаточно длительное время. И вот в 2015 году случилось то, что многие так ждали. В стандарте ECMAScript 2015 появилась возможность описывать модули штатными средствами языка.
```javascript
// файл mother.js
const name = `Eve`;

export { name };

// файл father.js
const name = `Adam`;

export { name };

// файл сain.js
import { name as motherName } from './mother.js';
import { name as fatherName } from './father.js';

const name = `Сain`;

console.log(`My mother is`, motherName);
```
Чтобы браузер считал JS-файл модулем, его нужно подключить как модуль:
```html
<script type="module" src="..."></script>
```
В противном случае модульные конструкции вроде import и export ничего кроме ошибки не вызовут.

Модули ECMAScript 2015 выполняют все задачи, которые мы ставили в начале статьи:

* они ограничивают область видимости переменных и нам больше не нужно городить IIFE и подобное;
* у модулей есть синтаксис для описания зависимостей;
* у модулей есть синтаксис для описания интерфейса.

Кроме того, модули, за счёт ```import``` и ```export``` непосредственно внутри JavaScript кода, частично решают проблему порядка подключения JS-файлов. С модулями об этом можно больше не думать.

